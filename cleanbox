#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'yaml'

require 'rubygems'
require 'bundler'

ENV['RACK_ENV'] ||= 'development'
config_env = ENV['RACK_ENV']

bundler_env = ENV['BUNDLER_ENV'] || config_env
Bundler.require(:default, bundler_env)

# require 'pry'
# require 'gmail_xoauth'
require 'net/imap'
# require 'mail'
require_relative 'lib/core_ext'
require_relative 'lib/connection'
require_relative 'lib/cleanbox'
require_relative 'lib/cleanbox_folder'
require_relative 'lib/folder_checker'
require_relative 'lib/message'
require_relative 'lib/microsoft_365_application_token'

require 'logger'

SECRETS_PATH = '/var/run/secrets/'

# Config file path - can be overridden by CLEANBOX_CONFIG environment variable
CONFIG_PATH = ENV.fetch('CLEANBOX_CONFIG', File.expand_path('~/.cleanbox.yml'))

def value_from_env_or_secrets(variable)
  val = ENV[variable.to_s.upcase] || password_from_secrets(variable.to_s)
  val.chomp if val.present?
end

def password_from_secrets(variable)
  secret_file = "#{secrets_path}#{variable}"
  return unless File.exist?(secret_file)

  File.read(secret_file).chomp
end

def secrets_path
  ENV.fetch('SECRETS_PATH') { SECRETS_PATH }
end

def determine_auth_type(host, auth_type)
  return auth_type if auth_type.present?
  
  # Auto-detect based on host
  case host
  when /outlook\.office365\.com/
    'oauth2_microsoft'
  when /imap\.gmail\.com/
    'oauth2_gmail'
  else
    'password'  # Default to password auth for other IMAP servers
  end
end

def authenticate_imap(imap, options)
  auth_type = determine_auth_type(options[:host], options[:auth_type])
  
  case auth_type
  when 'oauth2_microsoft'
    token_request = Microsoft365ApplicationToken.new(
      options[:client_id], 
      options[:client_secret], 
      options[:tenant_id]
    )
    imap.authenticate('XOAUTH2', options[:username], token_request.token)
  when 'oauth2_gmail'
    # TODO: Implement Gmail OAuth2 when needed
    raise "Gmail OAuth2 not yet implemented"
  when 'password'
    imap.authenticate('PLAIN', options[:username], options[:password])
  else
    raise "Unknown authentication type: #{auth_type}"
  end
end

def load_config
  return {} unless File.exist?(CONFIG_PATH)
  config = YAML.load_file(CONFIG_PATH) || {}
  # Convert string keys to symbols for consistency with options hash
  config.transform_keys(&:to_sym)
end

def save_config(config)
  FileUtils.mkdir_p(File.dirname(CONFIG_PATH))
  File.write(CONFIG_PATH, config.to_yaml)
  puts "Configuration saved to #{CONFIG_PATH}"
end

def handle_config_command(args)
  command = args.first
  
  case command
  when 'show'
    config = load_config
    if config.empty?
      puts "No configuration file found at #{CONFIG_PATH}"
    else
      puts "Configuration from #{CONFIG_PATH}:"
      puts config.to_yaml
    end
  
  when 'get'
    key = args[1]&.to_sym
    if key.nil?
      puts "Usage: cleanbox config get <key>"
      exit 1
    end
    
    config = load_config
    value = config[key]
    if value.nil?
      puts "Key '#{key}' not found in configuration"
    else
      puts value.to_yaml
    end
  
  when 'set'
    key = args[1]&.to_sym
    value = args[2]
    
    if key.nil? || value.blank?
      puts "Usage: cleanbox config set <key> <value>"
      puts "For complex values, edit the config file directly: #{CONFIG_PATH}"
      exit 1
    end
    
    config = load_config
    
    # Try to parse value as YAML for complex types
    begin
      parsed_value = YAML.load(value)
      config[key] = parsed_value
    rescue
      # If YAML parsing fails, treat as string
      config[key] = value
    end
    
    save_config(config)
  
  when 'add'
    key = args[1]&.to_sym
    value = args[2]
    
    if key.nil? || value.blank?
      puts "Usage: cleanbox config add <key> <value>"
      puts "This will append to arrays or merge with hashes"
      exit 1
    end
    
    config = load_config
    
    # Try to parse value as YAML for complex types
    begin
      parsed_value = YAML.load(value)
    rescue
      # If YAML parsing fails, treat as string
      parsed_value = value
    end
    
    # Handle different types
    if config[key].is_a?(Array)
      # Append to array
      config[key] << parsed_value
      puts "Added '#{parsed_value}' to #{key}"
    elsif config[key].is_a?(Hash) && parsed_value.is_a?(Hash)
      # Merge with hash
      config[key] = config[key].deep_merge(parsed_value)
      puts "Merged hash into #{key}"
    elsif config[key].nil?
      # Create new array or hash based on value type
      if parsed_value.is_a?(Hash)
        config[key] = parsed_value
        puts "Created new hash for #{key}"
      else
        config[key] = [parsed_value]
        puts "Created new array for #{key} with '#{parsed_value}'"
      end
    else
      puts "Cannot add to #{key} (type: #{config[key].class})"
      exit 1
    end
    
    save_config(config)
  
  when 'remove'
    key = args[1]&.to_sym
    value = args[2]
    
    if key.nil? || value.blank?
      puts "Usage: cleanbox config remove <key> <value>"
      puts "This will remove from arrays or delete keys from hashes"
      exit 1
    end
    
    config = load_config
    
    # Try to parse value as YAML for complex types
    begin
      parsed_value = YAML.load(value)
    rescue
      # If YAML parsing fails, treat as string
      parsed_value = value
    end
    
    # Handle different types
    if config[key].is_a?(Array)
      # Remove from array
      if config[key].include?(parsed_value)
        config[key].delete(parsed_value)
        puts "Removed '#{parsed_value}' from #{key}"
      else
        puts "Value '#{parsed_value}' not found in #{key}"
      end
    elsif config[key].is_a?(Hash) && parsed_value.is_a?(Hash)
      # Remove keys from hash
      removed_keys = []
      parsed_value.each_key do |k|
        if config[key].key?(k)
          config[key].delete(k)
          removed_keys << k
        end
      end
      if removed_keys.any?
        puts "Removed keys #{removed_keys.join(', ')} from #{key}"
      else
        puts "No matching keys found in #{key}"
      end
    elsif config[key].nil?
      puts "Key '#{key}' not found in configuration"
      exit 1
    else
      puts "Cannot remove from #{key} (type: #{config[key].class})"
      exit 1
    end
    
    save_config(config)
  
  when 'init'
    if File.exist?(CONFIG_PATH)
      puts "Configuration file already exists at #{CONFIG_PATH}"
      puts "Use 'cleanbox config show' to view it"
    else
      default_config = {
        'host' => 'outlook.office365.com',
        'username' => 'your-email@example.com',
        'auth_type' => 'oauth2_microsoft',
        'clean_folders' => ['Work', 'Personal'],
        'whitelisted_domains' => ['example.com'],
        'list_folders' => ['Lists', 'Notifications'],
        'domain_map' => {
          'example.com' => 'Example'
        }
      }
      save_config(default_config)
      puts "Initial configuration created at #{CONFIG_PATH}"
      puts "Please edit it with your actual settings"
    end
  
  else
    puts "Unknown config command: #{command}"
    puts "Available commands: show, get, set, add, remove, init"
    exit 1
  end
end

options = {
  host: '',
  username: nil,
  auth_type: nil,  # oauth2_microsoft, oauth2_gmail, password
  clean_folders: [],
  whitelisted_domains: [],
  list_domains: [],
  list_folders: [],
  domain_map: {},
  pretend: false,
  sent_folder: 'Sent Items',
  move_read: false,
  client_id: value_from_env_or_secrets(:client_id),
  client_secret: value_from_env_or_secrets(:client_secret),
  tenant_id: value_from_env_or_secrets(:tenant_id),
  password: value_from_env_or_secrets(:password),
  unjunk: false,
  unjunk_folders: [],
  file_from_folders: []
}

# Load config file if it exists
if File.exist?(CONFIG_PATH)
  config_options = load_config
  options = options.deep_merge(config_options)
end

action = 'clean!'

# rubocop:disable Metrics/BlockLength
parsed_options = OptionParser.new do |opts|
  opts.banner = 'Usage: cleanbox [options] [command]'

  opts.on('-v', '--verbose', 'Run verbosely') do |v|
    options[:verbose] = v
    options[:level] = 'debug'
  end

  opts.on('-h', '--help', 'Prints this help') do
    puts opts
    exit
  end

  opts.on('-n', '--pretend', 'Only show what would happen') do
    options[:pretend] = true
  end

  loglevel_help = 'log level, should be one of debug, info, warn, error'
  opts.on('-L', '--level loglevel', loglevel_help) do |value|
    options[:level] = value
  end

  host_help = "Set the IMAP hostname (default '#{options[:host]}'"
  opts.on('-H', '--host HOST', host_help) do |val|
    options[:host] = val
  end

  opts.on('-u', '--user USERNAME', 'Set IMAP username') do |val|
    options[:username] = val
  end

  opts.on('-p', '--password PASSWORD', 'Set IMAP password') do |val|
    options[:password] = val
  end

  opts.on('-C', '--client_id CLIENT_ID', 'Set client id for ouath2 token') do |val|
    options[:client_id] = val
  end

  opts.on('-S', '--client_secret SECRET', 'Set client secret for ouath2 token') do |val|
    options[:client_secret] = val
  end

  opts.on('-T', '--tenant_id TENANT_ID', 'Set tenant id for ouath2 token') do |val|
    options[:tenant_id] = val
  end

  logfile_help = 'Specify log file (defaults to STDOUT)'
  opts.on('-l', '--log-file LOGFILE', logfile_help) do |val|
    options[:log_file] = val
  end

  since_help = 'Only apply to messages since <parseable date>'
  opts.on('-s', '--since DATE', since_help) do |val|
    options[:since] = val
  end

  valid_from_help = 'Use addresses found since this date (default 1 year ago)'
  opts.on('-f', '--valid-from DATE', valid_from_help) do |val|
    options[:valid_from] = val
  end

  opts.on('-J', '--unjunk FOLDER', 'Unjunk based on mail in FOLDER (can use multiple times)') do |folder|
    options[:unjunk_folders] << folder
    options[:unjunk] = true
  end

  opts.on('-F', '--file-from FOLDER', 'File (from the Inbox) based on mail in FOLDER (can use multiple times)') do |folder|
    options[:file_from_folders] << folder
  end

  opts.separator ''
  opts.separator 'Commands:'
  opts.separator ''
  opts.separator '  list'
  opts.separator '    show the mapping of email addresses to folders for filing'
  opts.separator ''
  opts.separator '  file'
  opts.separator '    file any message in the Inbox based on folders (or FOLDER if specified)'
  opts.separator ''
  opts.separator '  folders'
  opts.separator '    list all folders'
  opts.separator ''
  opts.separator '  config'
  opts.separator '    manage configuration file'
  opts.separator ''
end
# rubocop:enable Metrics/BlockLength

parsed_options.parse!

# Validate required options
if options[:host].blank?
  puts "Error: IMAP host is required. Set it in ~/.cleanbox.yml or use --host option."
  exit 1
end

if options[:username].blank?
  puts "Error: IMAP username is required. Set it in ~/.cleanbox.yml or use --user option."
  exit 1
end

# Validate authentication requirements
auth_type = determine_auth_type(options[:host], options[:auth_type])
case auth_type
when 'oauth2_microsoft'
  if options[:client_id].blank? || options[:client_secret].blank? || options[:tenant_id].blank?
    puts "Error: OAuth2 Microsoft requires client_id, client_secret, and tenant_id."
    puts "Set them in environment variables or secrets."
    exit 1
  end
when 'password'
  if options[:password].blank?
    puts "Error: Password authentication requires password."
    puts "Set it in environment variables or secrets."
    exit 1
  end
end

# Net::IMAP.debug = true

# Handle config commands first
if ARGV.first == 'config'
  handle_config_command(ARGV[1..-1])
  exit 0
end

imap = Net::IMAP.new(options.delete(:host), ssl: true)
authenticate_imap(imap, options)

action = 'show_lists!' if ARGV.last == 'list'
action = 'file_messages!' if %w[file filing].include?(ARGV.last)
# puts "Action: #{action}"
# puts "Args: #{ARGV.inspect}"
action = 'show_folders!' if ARGV.last == 'folders'

action = 'unjunk!' if options[:unjunk]

Cleanbox.new(imap, options).send(action)
